@page "/snake/custom"
@implements IDisposable
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager
@inject BlazorApp1.Services.SnakeGameEngine GameEngine
@using BlazorApp1.Models

<PageTitle>Custom Snake Level</PageTitle>

<h1>Custom Level Creator</h1>

<div class="custom-level-container">
    @if (!levelStarted)
    {
        <div class="editor-with-preview">
            <div class="level-editor">
                <h2>Create Your Level</h2>
                
                <div class="form-group">
                    <label>Description:</label>
                    <input type="text" @bind="description" @bind:event="oninput" placeholder="My Custom Level" class="form-control" />
                </div>


            <div class="button-group">
                <button class="game-button" @onclick="PlayLevel">Play Level</button>
                <button class="game-button" @onclick="ShareLevel">Share Level</button>
                <button class="game-button" @onclick="SaveLevel">Save Level</button>
                <button class="game-button secondary" @onclick="BackToMenu">Back to Menu</button>
            </div>

            @if (showSavePrompt)
            {
                <div class="save-section">
                    <h3>Save Level</h3>
                    <div class="form-group">
                        <label>Level Name:</label>
                        <input type="text" @bind="saveLevelName" placeholder="My Awesome Level" class="form-control" />
                    </div>
                    <div class="button-group">
                        <button class="game-button" @onclick="ConfirmSaveLevel">Confirm Save</button>
                        <button class="game-button secondary" @onclick="CancelSave">Cancel</button>
                    </div>
                </div>
            }

            @if (savedLevels.Any())
            {
                <div class="saved-levels-section">
                    <h3>Saved Levels</h3>
                    <div class="saved-levels-list">
                        @foreach (var level in savedLevels)
                        {
                            <div class="saved-level-item">
                                <span class="saved-level-name" @onclick="() => LoadSavedLevel(level.Key)">@level.Key</span>
                                <button class="delete-button" @onclick="() => DeleteSavedLevel(level.Key)">üóëÔ∏è</button>
                            </div>
                        }
                    </div>
                </div>
            }

            @if (showShareUrl)
            {
                <div class="share-section">
                    <h3>Share this level:</h3>
                    <div class="share-url-box">
                        <input type="text" readonly @bind="shareUrl" class="share-url-input" @onclick="SelectShareUrl" />
                        <button class="copy-button" @onclick="CopyToClipboard">Copy</button>
                    </div>
                    <p class="share-hint">Share this URL with others to let them play your level!</p>
                </div>
            }

            @if (!string.IsNullOrEmpty(errorMessage))
            {
                <div class="error-message">
                    @errorMessage
                </div>
            }
        </div>
        
        <div class="level-preview">
            <div class="editor-header">
                <h3>Edit</h3>
                <div class="block-type-selectors">
                    <div class="block-selector @(selectedBlockType == "snake" ? "selected" : "")" @onclick='() => selectedBlockType = "snake"'>
                        <div class="block-preview snake-head"></div>
                    </div>
                    <div class="block-selector @(selectedBlockType == "apple" ? "selected" : "")" @onclick='() => selectedBlockType = "apple"'>
                        <div class="block-preview apple"></div>
                    </div>
                    <div class="block-selector @(selectedBlockType == "portal" ? "selected" : "")" @onclick='() => selectedBlockType = "portal"'>
                        <div class="block-preview portal"></div>
                    </div>
                    <div class="block-selector @(selectedBlockType == "ground" ? "selected" : "")" @onclick='() => selectedBlockType = "ground"'>
                        <div class="block-preview ground-block"></div>
                    </div>
                    <div class="block-selector @(selectedBlockType == "pushable" ? "selected" : "")" @onclick='() => selectedBlockType = "pushable"'>
                        <div class="block-preview pushable-block"></div>
                    </div>
                    <div class="block-selector @(selectedBlockType == "bomb" ? "selected" : "")" @onclick='() => selectedBlockType = "bomb"'>
                        <div class="block-preview bomb"></div>
                    </div>
                </div>
            </div>
            <InteractiveGameGrid 
                Snake="@snakeSegments"
                Apples="@apples"
                Portal="@portal"
                GroundBlocks="@groundBlocks"
                PushableBlocks="@pushableBlocks"
                Bombs="@bombs"
                OnCellClicked="@HandleCellClick" />
        </div>
    </div>
    }
    else if (levelWon)
    {
        <div class="level-complete">
            <h2>üéâ Level Complete! üéâ</h2>
            <p>You reached the portal!</p>
            <div class="completion-buttons">
                <button class="game-button" @onclick="BackToEditor">Back to Editor</button>
                <button class="game-button secondary" @onclick="BackToMenu">Main Menu</button>
            </div>
        </div>
    }
    else if (gameOver)
    {
        <GameGrid 
            Snake="@GameEngine.Snake"
            Apples="@GameEngine.Apples"
            Portal="@GameEngine.PortalPosition"
            GroundBlocks="@GameEngine.GroundBlocks"
            PushableBlocks="@GameEngine.PushableBlocks"
            Bombs="@GameEngine.Bombs" />
        <div class="controls">
            <div class="game-over-message">
                <h2>üí• Game Over! üí•</h2>
                <p class="game-over-reason">@gameOverReason</p>
            </div>
            <div class="completion-buttons">
                <button class="game-button" @onclick="RetryLevel">Retry Level</button>
                <button class="game-button secondary" @onclick="BackToEditor">Back to Editor</button>
            </div>
        </div>
    }
    else
    {
        <GameGrid 
            Snake="@GameEngine.Snake"
            Apples="@GameEngine.Apples"
            Portal="@GameEngine.PortalPosition"
            GroundBlocks="@GameEngine.GroundBlocks"
            PushableBlocks="@GameEngine.PushableBlocks"
            Bombs="@GameEngine.Bombs" />
        <div class="controls">
            <div class="button-row">
                <button class="arrow-button" @onclick="() => ChangeDirection(Services.Direction.Up)">‚ñ≤</button>
            </div>
            <div class="button-row">
                <button class="arrow-button" @onclick="() => ChangeDirection(Services.Direction.Left)">‚óÑ</button>
                <button class="arrow-button" @onclick="() => ChangeDirection(Services.Direction.Down)">‚ñº</button>
                <button class="arrow-button" @onclick="() => ChangeDirection(Services.Direction.Right)">‚ñ∫</button>
            </div>
            <div class="button-row">
                <button class="game-button" @onclick="RetryLevel">Retry</button>
                <button class="game-button secondary" @onclick="BackToEditor">Back to Editor</button>
            </div>
        </div>
    }
</div>

@code {
    private const int GridSize = 20;

    // Editor fields - now using lists instead of strings
    private string description = "";
    private List<Position> snakeSegments = new();
    private List<Position> apples = new();
    private Position? portal = null;
    private List<Position> groundBlocks = new();
    private List<Position> pushableBlocks = new();
    private List<Position> bombs = new();
    
    private string errorMessage = "";
    private bool showShareUrl = false;
    private string shareUrl = "";
    private string selectedBlockType = "snake"; // Which block type is currently selected
    private bool showSavePrompt = false;
    private string saveLevelName = "";
    private Dictionary<string, string> savedLevels = new();


    // Game state - use GameEngine properties
    private bool levelStarted = false;
    private bool levelWon => GameEngine.LevelWon;
    private bool gameOver => GameEngine.GameOver;
    private string gameOverReason => GameEngine.GameOverReason;

    // Store original config for retry
    private LevelConfig? currentConfig = null;

    protected override void OnInitialized()
    {
        // Subscribe to game engine state changes
        GameEngine.OnStateChanged += HandleGameEngineStateChanged;
        
        LoadFromUrl();
    }
    
    private void HandleGameEngineStateChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("setupKeyboardHandler", DotNetObjectReference.Create(this));
            await LoadSavedLevelsFromStorage();
        }
    }

    private void LoadFromUrl()
    {
        var uri = new Uri(NavigationManager.Uri);
        var query = uri.Query.TrimStart('?');
        
        if (string.IsNullOrEmpty(query))
            return;

        var parameters = query.Split('&');
        foreach (var param in parameters)
        {
            var equalIndex = param.IndexOf('=');
            if (equalIndex < 0) continue;

            var key = param.Substring(0, equalIndex);
            var value = System.Net.WebUtility.UrlDecode(param.Substring(equalIndex + 1));

            switch (key)
            {
                case "D":
                    description = value;
                    break;
                case "E":
                    portal = TryParsePosition(value);
                    break;
                case "S":
                    snakeSegments = ParsePositionListSafe(value);
                    break;
                case "A":
                    apples = ParsePositionListSafe(value);
                    break;
                case "G":
                    groundBlocks = ParsePositionListSafe(value);
                    break;
                case "P":
                    pushableBlocks = ParsePositionListSafe(value);
                    break;
                case "B":
                    bombs = ParsePositionListSafe(value);
                    break;
            }
        }

        // If we have data in the URL, auto-play the level
        if (snakeSegments.Any() && portal != null)
        {
            PlayLevel();
        }
    }

    private void PlayLevel()
    {
        try
        {
            errorMessage = "";
            showShareUrl = false;

            // Validate required fields
            if (!ValidateLevel(out var validationError))
            {
                errorMessage = validationError;
                return;
            }

            var compactString = BuildCompactString();
            currentConfig = LevelConfig.Parse(compactString);
            
            InitializeGame(currentConfig);
            levelStarted = true;
        }
        catch (Exception ex)
        {
            errorMessage = $"Error: {ex.Message}";
        }
    }

    private bool ValidateLevel(out string error)
    {
        error = "";

        // Validate End Portal (required)
        if (portal == null)
        {
            error = "End Portal position is required. Click a cell with Portal selected.";
            return false;
        }

        // Validate Snake (required, at least 1 segment)
        if (snakeSegments.Count == 0)
        {
            error = "Snake segments are required (at least 1 segment). Click cells with Snake selected.";
            return false;
        }

        // Validate Ground Blocks (required, at least 3)
        if (groundBlocks.Count < 3)
        {
            error = $"Ground blocks must have at least 3 blocks (currently {groundBlocks.Count}). Click cells with Ground selected.";
            return false;
        }

        return true;
    }


    private void RetryLevel()
    {
        if (currentConfig != null)
        {
            InitializeGame(currentConfig);
            levelStarted = true;
        }
    }

    private void ShareLevel()
    {
        try
        {
            errorMessage = "";
            
            // Validate before sharing
            if (!ValidateLevel(out var validationError))
            {
                errorMessage = validationError;
                return;
            }

            var compactString = BuildCompactString();
            
            // Test parse to validate
            LevelConfig.Parse(compactString);
            
            // Build share URL
            var baseUrl = NavigationManager.BaseUri;
            shareUrl = $"{baseUrl}snake/custom?{compactString}";
            showShareUrl = true;
        }
        catch (Exception ex)
        {
            errorMessage = $"Error: {ex.Message}";
        }
    }

    private string BuildCompactString()
    {
        var parts = new List<string>();

        if (!string.IsNullOrWhiteSpace(description))
            parts.Add($"D={System.Net.WebUtility.UrlEncode(description)}");
        
        if (portal != null)
            parts.Add($"E={portal.Row},{portal.Col}");
        
        if (snakeSegments.Any())
            parts.Add($"S={string.Join(";", snakeSegments.Select(p => $"{p.Row},{p.Col}"))}");
        
        if (apples.Any())
            parts.Add($"A={string.Join(";", apples.Select(p => $"{p.Row},{p.Col}"))}");
        
        if (groundBlocks.Any())
            parts.Add($"G={string.Join(";", groundBlocks.Select(p => $"{p.Row},{p.Col}"))}");
        
        if (pushableBlocks.Any())
            parts.Add($"P={string.Join(";", pushableBlocks.Select(p => $"{p.Row},{p.Col}"))}");
        
        if (bombs.Any())
            parts.Add($"B={string.Join(";", bombs.Select(p => $"{p.Row},{p.Col}"))}");

        return string.Join("&", parts);
    }

    private async Task SelectShareUrl()
    {
        await JSRuntime.InvokeVoidAsync("eval", "event.target.select()");
    }

    private async Task CopyToClipboard()
    {
        await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", shareUrl);
    }

    private void BackToEditor()
    {
        levelStarted = false;
        showShareUrl = false;
    }

    private void BackToMenu()
    {
        NavigationManager.NavigateTo("/snake");
    }

    // Save/Load/Delete functionality
    private async Task LoadSavedLevelsFromStorage()
    {
        try
        {
            var levelsJson = await JSRuntime.InvokeAsync<Dictionary<string, string>>("getSavedLevels");
            savedLevels = levelsJson ?? new Dictionary<string, string>();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading saved levels: {ex.Message}");
            savedLevels = new Dictionary<string, string>();
        }
    }

    private void SaveLevel()
    {
        // Validate before showing save prompt
        if (!ValidateLevel(out var validationError))
        {
            errorMessage = validationError;
            return;
        }

        errorMessage = "";
        showShareUrl = false;
        showSavePrompt = true;
        saveLevelName = description; // Pre-fill with description
    }

    private void CancelSave()
    {
        showSavePrompt = false;
        saveLevelName = "";
    }

    private async Task ConfirmSaveLevel()
    {
        try
        {
            if (string.IsNullOrWhiteSpace(saveLevelName))
            {
                errorMessage = "Please enter a name for the level";
                return;
            }

            var compactString = BuildCompactString();
            
            // Save to localStorage via JavaScript
            var success = await JSRuntime.InvokeAsync<bool>("saveCustomLevel", saveLevelName, compactString);
            
            if (success)
            {
                savedLevels[saveLevelName] = compactString;
                showSavePrompt = false;
                saveLevelName = "";
                errorMessage = "";
                StateHasChanged();
            }
            else
            {
                errorMessage = "Failed to save level. Please try again.";
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error saving level: {ex.Message}";
        }
    }

    private void LoadSavedLevel(string levelName)
    {
        try
        {
            if (!savedLevels.ContainsKey(levelName))
            {
                errorMessage = "Level not found";
                return;
            }

            var compactString = savedLevels[levelName];
            var parameters = compactString.Split('&');
            
            // Reset all fields
            description = "";
            portal = null;
            snakeSegments = new List<Position>();
            apples = new List<Position>();
            groundBlocks = new List<Position>();
            pushableBlocks = new List<Position>();
            bombs = new List<Position>();
            
            // Parse the saved level data
            foreach (var param in parameters)
            {
                var equalIndex = param.IndexOf('=');
                if (equalIndex < 0) continue;

                var key = param.Substring(0, equalIndex);
                var value = System.Net.WebUtility.UrlDecode(param.Substring(equalIndex + 1));

                switch (key)
                {
                    case "D":
                        description = value;
                        break;
                    case "E":
                        portal = TryParsePosition(value);
                        break;
                    case "S":
                        snakeSegments = ParsePositionListSafe(value);
                        break;
                    case "A":
                        apples = ParsePositionListSafe(value);
                        break;
                    case "G":
                        groundBlocks = ParsePositionListSafe(value);
                        break;
                    case "P":
                        pushableBlocks = ParsePositionListSafe(value);
                        break;
                    case "B":
                        bombs = ParsePositionListSafe(value);
                        break;
                }
            }

            errorMessage = "";
            showShareUrl = false;
            showSavePrompt = false;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            errorMessage = $"Error loading level: {ex.Message}";
        }
    }

    private async Task DeleteSavedLevel(string levelName)
    {
        try
        {
            var success = await JSRuntime.InvokeAsync<bool>("deleteCustomLevel", levelName);
            
            if (success)
            {
                savedLevels.Remove(levelName);
                errorMessage = "";
                StateHasChanged();
            }
            else
            {
                errorMessage = "Failed to delete level. Please try again.";
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error deleting level: {ex.Message}";
        }
    }

    // Helper methods for parsing position strings
    private List<Position> ParsePositionListSafe(string input)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(input))
                return new List<Position>();
            
            return input.Split(';')
                .Select(p => p.Trim())
                .Where(p => !string.IsNullOrWhiteSpace(p))
                .Select(p => TryParsePosition(p))
                .OfType<Position>()
                .ToList();
        }
        catch
        {
            return new List<Position>();
        }
    }


    private Position? TryParsePosition(string posStr)
    {
        try
        {
            var parts = posStr.Split(',');
            if (parts.Length != 2)
                return null;
            
            if (!int.TryParse(parts[0].Trim(), out int row))
                return null;
            
            if (!int.TryParse(parts[1].Trim(), out int col))
                return null;

            if (row < 0 || row >= 20 || col < 0 || col >= 20)
                return null;

            return new Position(row, col);
        }
        catch
        {
            return null;
        }
    }

    private void HandleCellClick((int row, int col, string cellType) clickInfo)
    {
        var pos = new Position(clickInfo.row, clickInfo.col);
        
        // If cell is not empty, remove it from the appropriate list and switch to that block type
        if (!string.IsNullOrEmpty(clickInfo.cellType))
        {
            RemoveBlockAtPosition(pos, clickInfo.cellType);
            // Switch to the block type that was just removed
            selectedBlockType = MapCellTypeToBlockType(clickInfo.cellType);
        }
        // If cell is empty, add a block of the selected type
        else
        {
            AddBlockAtPosition(pos, selectedBlockType);
        }
        
        StateHasChanged();
    }

    private string MapCellTypeToBlockType(string cellType)
    {
        return cellType switch
        {
            "snake-head" => "snake",
            "snake-body" => "snake",
            "apple" => "apple",
            "portal" => "portal",
            "ground-block" => "ground",
            "pushable-block" => "pushable",
            "bomb" => "bomb",
            _ => selectedBlockType
        };
    }

    private void RemoveBlockAtPosition(Position pos, string cellType)
    {
        switch (cellType)
        {
            case "snake-head":
            case "snake-body":
                snakeSegments.Remove(pos);
                break;
            case "apple":
                apples.Remove(pos);
                break;
            case "portal":
                portal = null;
                break;
            case "ground-block":
                groundBlocks.Remove(pos);
                break;
            case "pushable-block":
                pushableBlocks.Remove(pos);
                break;
            case "bomb":
                bombs.Remove(pos);
                break;
        }
    }

    private void AddBlockAtPosition(Position pos, string blockType)
    {
        switch (blockType)
        {
            case "snake":
                if (!snakeSegments.Contains(pos))
                    snakeSegments.Add(pos);
                break;
            case "apple":
                if (!apples.Contains(pos))
                    apples.Add(pos);
                break;
            case "portal":
                portal = pos;
                break;
            case "ground":
                if (!groundBlocks.Contains(pos))
                    groundBlocks.Add(pos);
                break;
            case "pushable":
                if (!pushableBlocks.Contains(pos))
                    pushableBlocks.Add(pos);
                break;
            case "bomb":
                if (!bombs.Contains(pos))
                    bombs.Add(pos);
                break;
        }
    }


    private void InitializeGame(LevelConfig config)
    {
        GameEngine.InitializeGame(
            config.SnakeSegments,
            config.Apples,
            config.Portal,
            config.GroundBlocks,
            config.PushableBlocks,
            config.Bombs
        );
    }

    private void ChangeDirection(Services.Direction newDirection)
    {
        if (levelWon || gameOver || GameEngine.IsAnimating)
            return;

        // Use synchronous version without animation for custom level editor
        GameEngine.MoveSnake(newDirection);
    }

    [JSInvokable]
    public void HandleKeyPress(string key)
    {
        if (!levelStarted || levelWon || gameOver || GameEngine.IsAnimating)
            return;

        var direction = key switch
        {
            "ArrowUp" => Services.Direction.Up,
            "ArrowDown" => Services.Direction.Down,
            "ArrowLeft" => Services.Direction.Left,
            "ArrowRight" => Services.Direction.Right,
            _ => (Services.Direction?)null
        };

        if (direction.HasValue)
        {
            ChangeDirection(direction.Value);
        }
    }

    public void Dispose()
    {
        // Unsubscribe from game engine events
        GameEngine.OnStateChanged -= HandleGameEngineStateChanged;
        
        // Clean up keyboard handler
        JSRuntime.InvokeVoidAsync("cleanupKeyboardHandler");
    }
}

